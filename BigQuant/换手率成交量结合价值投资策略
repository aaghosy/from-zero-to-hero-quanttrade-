from bigmodule import M

# <aistudiograph>

# @param(id="m3", name="initialize")
# 交易引擎：初始化函数，只执行一次
def m3_initialize_bigquant_run(context):
    # 系统已经设置了默认的交易手续费和滑点，要修改手续费可使用如下函数
    from bigtrader.finance.commission import PerOrder
    context.set_commission(PerOrder(buy_cost=0.0003, sell_cost=0.0013, min_cost=5))
    
    # 设置买入的股票数量，这里买入预测股票列表排名靠前的5只
    context.stock_count = 5

    # 每只股票的权重平均分配
    context.stock_weights = 1/context.stock_count
     
    # 每日换仓数
    context.change_num = 1
    
    context.my_data = context.data.sort_values(["date", "position"])

# @param(id="m3", name="before_trading_start")
# 交易引擎：每个单位时间开盘前调用一次。
def m3_before_trading_start_bigquant_run(context, data):
    # 盘前处理，订阅行情等
    pass

# @param(id="m3", name="handle_tick")
# 交易引擎：tick数据处理函数，每个tick执行一次
def m3_handle_tick_bigquant_run(context, tick):
    pass

# @param(id="m3", name="handle_data")
# 回测引擎：每日数据处理函数，每天执行一次
def m3_handle_data_bigquant_run(context, data):
    today = data.current_dt.strftime('%Y-%m-%d')
    ranker_prediction = context.my_data[context.my_data.date == today]
    #获取当前持仓股票
    stock_now = {e: p for e, p in context.portfolio.positions.items() if p.amount>0}
    stock_now_num = len(stock_now); 
    #当日应该买入股票
    try:
        # 多取n只应对买不了的异常情况
        buy_list = ranker_prediction.instrument.unique()[:context.stock_count+1]
    except:
        buy_list = []
    
    
    sell_num = 0
    if len(stock_now) > 0:
        # 首先卖出不在预测集的 例如st了
        need_sell = [x for x in stock_now if x not in list(ranker_prediction.instrument.unique())]
        for instrument in need_sell:
            rv = context.order_target(instrument, 0)
            if rv!=0:
                print(f"{instrument} 不在预测集卖出失败 { context.get_error_msg(rv)}")
                continue
            sell_num += 1
            
        # 持有的票按照预测得分排序，卖出得分低的
        instruments = list(reversed(list(ranker_prediction.instrument[ranker_prediction.instrument.apply(lambda x: x in stock_now)])))
        for instrument in instruments:
            if sell_num<context.change_num:
                rv = context.order_target(instrument, 0)
                if rv!=0:
                    print(f"{instrument} 卖出失败 { context.get_error_msg(rv)}")
                    continue
                sell_num += 1    
  

    #有卖出就买入
    if  len(buy_list) > 0 and stock_now_num < context.stock_count:
        buy_instruments = [i for i in buy_list if i not in stock_now] 
        #等权重买入，现金不够系统会自动调整
        cash_now = context.portfolio.cash / (context.stock_count - stock_now_num)
        cash_for_buy = min(context.portfolio.portfolio_value * context.stock_weights,cash_now)
        for instrument in buy_instruments:
            if stock_now_num < context.stock_count:  
                rv = context.order_value(instrument, cash_for_buy)
                if rv!=0:
                    print(f"{instrument} 买入失败 { context.get_error_msg(rv)}")
                    continue
                stock_now_num = stock_now_num +1

# @param(id="m3", name="handle_trade")
# 交易引擎：成交回报处理函数，每个成交发生时执行一次
def m3_handle_trade_bigquant_run(context, trade):
    pass

# @param(id="m3", name="handle_order")
# 交易引擎：委托回报处理函数，每个委托变化时执行一次
def m3_handle_order_bigquant_run(context, order):
    pass

# @param(id="m3", name="after_trading")
# 交易引擎：盘后处理函数，每日盘后执行一次
def m3_after_trading_bigquant_run(context, data):
    pass

# @module(position="-508,-1406", comment="""""", comment_collapsed=True)
m4 = M.input_features_dai.v27(
    mode="""表达式""",
    expr="""position""",
    expr_filters="""""",
    expr_tables="""user_formydream_48f019f0""",
    extra_fields="""date, instrument""",
    order_by="""date, instrument""",
    expr_drop_na=True,
    expr_add_sql=False,
    sql="""-- 使用DAI SQL获取数据, 构建因子等, 如下是一个例子作为参考
-- DAI SQL 语法: https://bigquant.com/wiki/doc/dai-PLSbc1SbZX#h-sql%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B
-- 使用数据输入1/2/3里的字段: e.g. input_1.close, input_1.* EXCLUDE(date, instrument)

SELECT
    -- 在这里输入因子表达式
    -- DAI SQL 算子/函数: https://bigquant.com/wiki/doc/dai-PLSbc1SbZX#h-%E5%87%BD%E6%95%B0
    -- 数据&字段: 数据文档 https://bigquant.com/data/home

    m_lag(close, 90) / close AS return_90,
    m_lag(close, 30) / close AS return_30,
    -- 下划线开始命名的列是中间变量, 不会在最终结果输出 (e.g. _rank_return_90)
    c_pct_rank(-return_90) AS _rank_return_90,
    c_pct_rank(return_30) AS _rank_return_30,

    c_rank(volume) AS rank_volume,
    close / m_lag(close, 1) as return_0,

    -- 日期和股票代码
    date, instrument
FROM
    -- 预计算因子 cn_stock_bar1d https://bigquant.com/data/datasources/cn_stock_bar1d
    cn_stock_prefactors
    -- SQL 模式不会自动join输入数据源, 可以根据需要自由灵活的使用
    -- JOIN input_1 USING(date, instrument)
WHERE
    -- WHERE 过滤, 在窗口等计算算子之前执行
    -- 剔除ST股票
    st_status = 0
QUALIFY
    -- QUALIFY 过滤, 在窗口等计算算子之后执行, 比如 m_lag(close, 3) AS close_3, 对于 close_3 的过滤需要放到这里
    -- 去掉有空值的行
    COLUMNS(*) IS NOT NULL
    -- _rank_return_90 是窗口函数结果，需要放在 QUALIFY 里
    AND _rank_return_90 > 0.1
    AND _rank_return_30 < 0.1
-- 按日期和股票代码排序, 从小到大
ORDER BY date, instrument
""",
    extract_data=False,
    m_cached=False,
    m_name="""m4"""
)

# @module(position="-501,-1315", comment="""""", comment_collapsed=True)
m7 = M.extract_data_dai.v17(
    sql=m4.data,
    start_date="""2022-11-18""",
    start_date_bound_to_trading_date=True,
    end_date="""2024-05-24""",
    end_date_bound_to_trading_date=True,
    before_start_days=90,
    debug=False,
    m_name="""m7"""
)

# @module(position="-528,-1189", comment="""""", comment_collapsed=True)
m3 = M.bigtrader.v19(
    data=m7.data,
    start_date="""""",
    end_date="""""",
    initialize=m3_initialize_bigquant_run,
    before_trading_start=m3_before_trading_start_bigquant_run,
    handle_tick=m3_handle_tick_bigquant_run,
    handle_data=m3_handle_data_bigquant_run,
    handle_trade=m3_handle_trade_bigquant_run,
    handle_order=m3_handle_order_bigquant_run,
    after_trading=m3_after_trading_bigquant_run,
    capital_base=1000000,
    frequency="""daily""",
    product_type="""股票""",
    rebalance_period_type="""交易日""",
    rebalance_period_days="""1""",
    rebalance_period_roll_forward=True,
    backtest_engine_mode="""标准模式""",
    before_start_days=0,
    volume_limit=1,
    order_price_field_buy="""open""",
    order_price_field_sell="""close""",
    benchmark="""沪深300指数""",
    plot_charts=True,
    debug=False,
    backtest_only=False,
    m_name="""m3"""
)
# </aistudiograph>
